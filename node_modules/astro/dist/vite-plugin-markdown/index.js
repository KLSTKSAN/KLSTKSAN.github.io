import { renderMarkdown } from "@astrojs/markdown-remark";
import ancestor from "common-ancestor-path";
import esbuild from "esbuild";
import fs from "fs";
import matter from "gray-matter";
import { fileURLToPath } from "url";
import { pagesVirtualModuleId } from "../core/app/index.js";
import { collectErrorMetadata } from "../core/errors.js";
import { warn } from "../core/logger/core.js";
import { resolvePages } from "../core/util.js";
import { cachedCompilation } from "../vite-plugin-astro/compile.js";
import { getViteTransform } from "../vite-plugin-astro/styles.js";
import { PAGE_SSR_SCRIPT_ID } from "../vite-plugin-scripts/index.js";
import { getFileInfo } from "../vite-plugin-utils/index.js";
const MARKDOWN_IMPORT_FLAG = "?mdImport";
const MARKDOWN_CONTENT_FLAG = "?content";
function safeMatter(source, id) {
  try {
    return matter(source);
  } catch (e) {
    e.id = id;
    throw collectErrorMetadata(e);
  }
}
function markdown({ config, logging }) {
  function normalizeFilename(filename) {
    if (filename.startsWith("/@fs")) {
      filename = filename.slice("/@fs".length);
    } else if (filename.startsWith("/") && !ancestor(filename, config.root.pathname)) {
      filename = new URL("." + filename, config.root).pathname;
    }
    return filename;
  }
  const fakeRootImporter = fileURLToPath(new URL("index.html", config.root));
  function isRootImport(importer) {
    if (!importer) {
      return true;
    }
    if (importer === fakeRootImporter) {
      return true;
    }
    if (importer === "\0" + pagesVirtualModuleId) {
      return true;
    }
    return false;
  }
  let viteTransform;
  return {
    name: "astro:markdown",
    enforce: "pre",
    configResolved(_resolvedConfig) {
      viteTransform = getViteTransform(_resolvedConfig);
    },
    async resolveId(id, importer, options) {
      if (id.endsWith(`.md${MARKDOWN_CONTENT_FLAG}`)) {
        const resolvedId = await this.resolve(id, importer, { skipSelf: true, ...options });
        return resolvedId == null ? void 0 : resolvedId.id.replace(MARKDOWN_CONTENT_FLAG, "");
      }
      if (id.endsWith(".md") && !isRootImport(importer)) {
        const resolvedId = await this.resolve(id, importer, { skipSelf: true, ...options });
        if (resolvedId) {
          return resolvedId.id + MARKDOWN_IMPORT_FLAG;
        }
      }
      return void 0;
    },
    async load(id, opts) {
      if (id.endsWith(`.md${MARKDOWN_IMPORT_FLAG}`)) {
        const { fileId, fileUrl } = getFileInfo(id, config);
        const source = await fs.promises.readFile(fileId, "utf8");
        const { data: frontmatter, content: rawContent } = safeMatter(source, fileId);
        return {
          code: `
						// Static
						export const frontmatter = ${escapeViteEnvReferences(JSON.stringify(frontmatter))};
						export const file = ${JSON.stringify(fileId)};
						export const url = ${JSON.stringify(fileUrl)};
						export function rawContent() {
							return ${escapeViteEnvReferences(JSON.stringify(rawContent))};
						}
						export async function compiledContent() {
							return load().then((m) => m.compiledContent());
						}
						export function $$loadMetadata() {
							return load().then((m) => m.$$metadata);
						}

						// Deferred
						export default async function load() {
							return (await import(${JSON.stringify(fileId + MARKDOWN_CONTENT_FLAG)}));
						}
						export function Content(...args) {
							return load().then((m) => m.default(...args));
						}
						Content.isAstroComponentFactory = true;
						export function getHeadings() {
							return load().then((m) => m.metadata.headings);
						}
						export function getHeaders() {
							console.warn('getHeaders() have been deprecated. Use getHeadings() function instead.');
							return load().then((m) => m.metadata.headings);
						};`,
          map: null
        };
      }
      if (id.endsWith(".md")) {
        const filename = normalizeFilename(id);
        const source = await fs.promises.readFile(filename, "utf8");
        const renderOpts = config.markdown;
        const isAstroFlavoredMd = config.legacy.astroFlavoredMarkdown;
        const fileUrl = new URL(`file://${filename}`);
        const isPage = fileUrl.pathname.startsWith(resolvePages(config).pathname);
        const hasInjectedScript = isPage && config._ctx.scripts.some((s) => s.stage === "page-ssr");
        let { data: frontmatter, content: markdownContent } = safeMatter(source, filename);
        if (isAstroFlavoredMd) {
          markdownContent = markdownContent.replace(
            /<\s*!--([^-->]*)(.*?)-->/gs,
            (whole) => `{/*${whole.replace(/\*\//g, "*\u200B/")}*/}`
          );
        }
        let renderResult = await renderMarkdown(markdownContent, {
          ...renderOpts,
          fileURL: fileUrl,
          isAstroFlavoredMd
        });
        let { code: astroResult, metadata } = renderResult;
        const { layout = "", components = "", setup = "", ...content } = frontmatter;
        content.astro = metadata;
        content.url = getFileInfo(id, config).fileUrl;
        content.file = filename;
        if (setup && !isAstroFlavoredMd) {
          warn(
            logging,
            "markdown",
            `[${id}] Astro now supports MDX! Support for components in ".md" files using the "setup" frontmatter is no longer enabled by default. Migrate this file to MDX or add the "legacy.astroFlavoredMarkdown" config flag to re-enable support.`
          );
        }
        const prelude = `---
import Slugger from 'github-slugger';
${layout ? `import Layout from '${layout}';` : ""}
${isAstroFlavoredMd && components ? `import * from '${components}';` : ""}
${hasInjectedScript ? `import '${PAGE_SSR_SCRIPT_ID}';` : ""}
${isAstroFlavoredMd ? setup : ""}

const slugger = new Slugger();
function $$slug(value) {
	return slugger.slug(value);
}

const $$content = ${JSON.stringify(
          isAstroFlavoredMd ? content : { ...content, setup, components }
        )};

Object.defineProperty($$content.astro, 'headers', {
	get() {
		console.warn('[${JSON.stringify(id)}] content.astro.headers is now content.astro.headings.');
		return this.headings;
	}
});
---`;
        const imports = `${layout ? `import Layout from '${layout}';` : ""}
${isAstroFlavoredMd ? setup : ""}`.trim();
        if (!isAstroFlavoredMd) {
          astroResult = `<Fragment set:html={${JSON.stringify(astroResult)}} />`;
        }
        if (/\bLayout\b/.test(imports)) {
          astroResult = `${prelude}
<Layout content={$$content}>

${astroResult}

</Layout>`;
        } else {
          astroResult = `${prelude}
${astroResult}`;
        }
        const compileProps = {
          config,
          filename,
          moduleId: id,
          source: astroResult,
          ssr: Boolean(opts == null ? void 0 : opts.ssr),
          viteTransform,
          pluginContext: this
        };
        let transformResult = await cachedCompilation(compileProps);
        let { code: tsResult } = transformResult;
        tsResult = `
export const metadata = ${JSON.stringify(metadata)};
export const frontmatter = ${JSON.stringify(content)};
export function rawContent() {
	return ${JSON.stringify(markdownContent)};
}
export function compiledContent() {
		return ${JSON.stringify(renderResult.metadata.html)};
}
${tsResult}`;
        const { code } = await esbuild.transform(tsResult, {
          loader: "ts",
          sourcemap: false,
          sourcefile: id
        });
        const astroMetadata = {
          clientOnlyComponents: transformResult.clientOnlyComponents,
          hydratedComponents: transformResult.hydratedComponents,
          scripts: transformResult.scripts
        };
        return {
          code: escapeViteEnvReferences(code),
          map: null,
          meta: {
            astro: astroMetadata,
            vite: {
              lang: "ts"
            }
          }
        };
      }
      return null;
    }
  };
}
function escapeViteEnvReferences(code) {
  return code.replace(/import\.meta\.env/g, "import\\u002Emeta.env");
}
export {
  markdown as default
};
